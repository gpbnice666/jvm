# 评估GC的性能指标

<font color=red>吞吐量：运行用户代码的时间占用总运行时间的比例</font>

​		用户运行时间/总运行时间：程序运行时间+内存回收的时间

垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例

<font color=red>暂停时间：执行垃圾收集时，程序的工作线程暂停的时间</font>

收集频率：相对于应用程序的执行，收集操作发生的频率

<font color=red>内存占用：Java堆区所占的内存大小</font>

快速：一个对象从诞生到被回收所经历的时间

![](.\png\暂停时间和吞吐量.jpg)





# Java常用的垃圾收集器

jdk1.3.1 Serial GC ，ParNew GC 是Serial GC的一个多线程的版本

jdk1.4.2 Parallel GC,和 Concurrent Mark Sweep GC(cms) 发布

jdk6之后 parallel GC 是默认的

jdk1.7.4 G1可用

jdk9 默认是 G1

jdk10 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏的情况下的低延迟

jdk11 发布引入 Epsilon垃圾回收器，No-Op（无操作）

jdk12 引入Shenandoah

jdk13发布 增强ZGC

jdk14 删除了CMS垃圾回收期

------------------------------------------------------------------------------------------------------------------

串行垃圾回收器：Serial、Serial Old

并行垃圾回收器：ParNew、Parallel Scavenge、Parallel Old

并发垃圾回收器：CMS、G1

![](.\png\经典垃圾回收器.jpg)





垃圾回收期之间分代关系

![](.\png\垃圾回收期的分代关系.jpg)



新生代：Serial、ParNew、Parallel Scavenge

老年代：Serial Old、Parallel Old、CMS

整个堆：G1





垃圾组合关系：

​		![](.\png\垃圾回收器组合.jpg)



# 查看用的垃圾收集器命令

-XX:+PrintCommandLineFlags       查看命令行相关参数

jinfo -flag 相关垃圾回收器参数  进程ID

# Serial回收器：串行回收

Serial收集器作为HotSpot中Client模式的默认新生代垃圾收集器

Serial收集器采用复制算法、串行回收和 Stop-the-World 机制的方式执行内存回收

Serial Old 收集器同样也采用了串行回收和 Stop-the-world 机制，只不过内存回收算法使用的标记-压缩法

Serial Old是运行在Client模式下默认的老年代的垃圾回收器

Serial Old是Server模式下主要有两个用途：

​				 与新生代的Parallel Scaveng配合使用

​				作为老年代的CMS回收期的备用方案

![](.\png\Serial垃圾回收器.jpg)

这个收集器是一个单线程的收集器、但它的 单线程 的意义并不仅仅说明它只会使用一个 CPU 会一条收集线程区完成垃圾收集工作，更重要的是在它进行垃圾回收集时，必须暂停其他所有的工作线程，直到它收集结束

优势：

​		简单而高效（与其他收集器的单线程比），对于限定单个CPU来说



-XX:+UseSerialGC 设置为使用SerialGC

总结：

​		这种垃圾收集器大家了解，现在已经不用串行的了，而且在限定单核CPU才可以用，现在都不是单核了

​		对于交互较强的应用而言，这种垃圾收集器是不能接受的，一般在Javaweb应用程序中不会采用串行垃圾收集器

# ParNew回收器：并行回收

如果Serial是单线程的，那么ParNew是多线程的

ParNew应用在新生代

ParNew收集器除了采用并行回收器方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别，ParNew收集器在年轻代同样采用的复制算法

ParNew 是很多JVM在Server模式下新生代的默认垃圾收集器

![](.\png\parNew.jpg)

对于新生代，回收次数频繁，使用并行方式高效

对于老年代、回收次数少，使用串行方式节省资源，



**由于ParNew收集器是基于并行回收，那么是否断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效**

ParNew收集器运行在多CPU的环境下，由于可以充分利用CPU，多核心等物理硬件资源优势，可以更快速的完成垃圾收集、提升程序的吞吐量

但是在单核CPU的环境下，ParNew收集器不必Serial收集器更高效，虽然Serial收集是基于串行的回收，但是由于CPU不需要频繁的做任务切换，因此可以有效避免多线程交互过程中产生一些额外开销

因为除了Serial外、目前只要PartNew GC能与CMS收集器配合工作



-XX:+ParNewGC  使用PartNewGC收集器

-XX:ParallelGCThreads=  限定线程数量，默认开启和CPU数据相同的 线程数

# ParallelGC 并行回收器

使用了 复制算法、并行回收和STW

和PartNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，它被称为吞吐量优先的垃圾收集器

自适应调节策略也是Parallel Scavenge与ParNew一个重要的区别

适合在后台运行不需要太多交互的任务

比如：批量处理、订单处理、科学处理

Parallel 收集器在jdk6时提供了用于执行老年代垃圾收集器的Parallel Old收集器、用于代替Serial Old收集器

Parallel Old 采用的 标记-压缩清理算法

![](.\png\parallel.jpg)



参数配置：

​		-XX:UseParallelGC 年轻代使用ParallelGC

​		-XX:UseParallelOldGC 老年代ParallelOldGC

​		-XX:ParallelGCThreads  设置年轻代并行收集器和线程数，一般的，最好于CPU数量相等，以避免过多的线程数影响垃圾收集性能

​		在默认情况下，当CPU 数量小于8个，ParallelGCThreads 的值等于CPU的数量

​		当CPU数量大于8个，ParallelGCThreads 值等于 3+((5*CPU_COUNT)/8)

​		-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间(STW的时间)单位毫秒

​			为了尽可能的把停顿时间控制在MaxGCPauseMills以内，收集器在工作时，会调整Java堆大小或者其他一些参数

​		对于用户来将，将停顿时间，越多越好，但是在服务器端，我们注重高并发放，整体的吞吐量，所以服务器端适合ParaLLel,进行控制

​			该参数慎用

​		-XX:GCTimeRatio 垃圾收集时间占总空间时间的比例（1/(n+1)）

用于衡量吞吐量的大小

​			取值范围(0,100) 默认99，也就是垃圾回收时间不超过1%

​			于前一个-XX:MaxGCPauseMillis参数有一定矛盾性，暂停时间越长。Radio参数容易草果设定比例

​		-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge 收集器具备自适应调节策略

​		  在这种模式下，年轻代的大小、Eden和Survivor的比例，晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点

​       在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量和停顿时间，让虚拟机自己完成调优工作

# CMS回收器 低延迟

在jdk5 时期，Hotspot推出一个款在 强交互引用的回收器

第一次让垃圾收集线程和用户线程同时工作

CMS收集器的关注点是尽可能缩短垃圾收集是用户线程的停顿时间，停顿时间越短，就越适合于用户交互的程序，良好的响应速度能提升用户体验

目前很大一部分的Java应用集中在互联网站，会在B/S 系统的服务的上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验CMS收集器就非常符合这类应用的需求

CMS是垃圾收集器采用算法是 标记-清除算法，并且会STW

不幸的是，CMS作为老年代的收集器，却无法于JDK1.4 中已经存在的新生代收集器Parallel Scavenge 配合工作，所以在JDK1.5中使用CMS 来收集老年代，新生代只能选择ParNew或者Serial收集器中的一个，jdk14移除了CMS

![](.\png\cms.jpg)

工作原理：

​		**初始化标记（Initial-Mark）**

​			在这个阶段中，程序中所有的工作线程都将会因为stw机制而出现短暂的暂停，<font color=red>这个阶段的主要任务仅仅只是标记出 GC Roots能直接关联到的对象，一旦标记完成之后</font>，就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里的速度非常快

**并发标记(Concurren-Mark)**

​		<font color=red>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不需要停顿用户线程，可以与垃圾线程一起并发运行</font>

**重新标记（Remark）**

​			由于在并发阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，<font color=red>因此为了修正并发标记期间，因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</font>，这个阶段的停顿时间通常会比初始化标记阶段稍长一些，但也远比并发阶段的时间段

**并发处理（Concurrent-Sweep）**

​			此阶段<font color=red>清理删除标记阶段判断的已经死亡的对象，释放内存空间，</font>由于不需要移动存活对象，所以这个阶段也是可以于用户线程同时并发执行的



<font color=blue>由于最耗时的时间并发标记于并发清除的阶段都不需要暂停工作，所以整体的回收时低停顿的</font>

另外，<font color=blue>由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用线程有足够的内存可用，因此，CMS收集器不能像其他收集器那样等到老年代几乎被填满了在进行收集，而是当堆内存使用率达到某一个阙值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行，要是CMS运行期间预留内存无法满足程序需要，就会进行一次 Concurrent ModeFailure 失败，这时虚拟机将启动后背预案，临时启用 Serial Old收集器来重新进行老年代的垃圾搜集这样停顿时间就长了	</font>

CMS收集器的垃圾收集算法采用的时标记-清除算法，这意味这每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能时不连续的一些内存块，不可避免的将会产生一些内存碎片，那么CMS在为新对象分配内存时，将无法使用指针碰撞，而只能使用空闲列表执行内存分配



**有人会说既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact?**

因为当并发处理的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提它运行的资源不受影响，Mark Compact更适合 Stop the World 这中长期使用



**CMS优点:**

​		并发收集、低延迟

**CMS的缺点：**

​		<font color=blue>会产生内存碎片：导致并发清除后，用户线程可用的空间不足，无法分配大对象的情况下，不得不提前触发Full GC</font>

​	<font color=blue>CMS收集器堆CPU资源非常敏感：在并发阶段，他虽然不会导致用户停顿，但是会因为占用了一部分线程进行垃圾清理，而导致程序变慢，总吞吐量会降低</font>

<font color=blue>CMS收集无法处理浮动垃圾：可能出现 Concurrent Mode Faulure 失败而导致另外一次Full GC的产生，在并发标记阶段由于程序的工作线程和垃圾收集线程时同时运行交叉运行的，<font color=red>那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被即使回收，</font> 从而只能在下一次执行GC时释放这些之前未被回收的内存空间</font>



参数：

​		-XX:+UseConcMarkSweepCG 使用CMS垃圾回收器

​		-XX:CMSInitiatingOccupanyFraction 设置堆内存使用率的阙值，一旦达到这个阙值，便开始进行垃圾  回收

​		JDK5及以前版本的默认值68，即当老年代的空间达到使用率68%时，会执行一次CMS回收

​		JDK6以以后默认是92%

​		如果内存增长缓慢，则可以设置一个稍大的阙值，大的阙值可以有效地降低CMS的触发频率，减少老年代回收的次数可以较为明显的改善应用程序性能，反之，如果应用程序内存使用率增长很快，则应该降低这个阙值，以避免触发老年代的Serial垃圾回收器，因此通过该选项可以有效降低Full GC 的执行次数

​      -XX:+UseCMSCompactAtFullCollection  用于指定在执行完full GC对内存进行一个整理，以此避免内存碎片的产生，不过由于内存压缩整理过程无法并发执行，所以带来的问题就是停顿时间变得更长

​	  -XX:CMSFullGCsBeforCompaction 设置在执行多少次Full GC后对内存空间进行压缩整理

​	  -XX:ParallelCMSThreads 设置CMS的线程数量

​			cms默认启动的线程数时(ParallelGCThread+3)/4

​			ParallelGCThreads 时年轻代并发收集器的线程数，当CPU资源比较紧张时，受到CMS收集线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕



**小结**

​		如果你想最小化使用内存和并行开销：Serial GC

​		如果你想要应用程序的吞吐量：Parallel GC

​		如果你想要最小化GC的中断或停顿时间：CMS GC

JDK9中 CMS被消除了

如果在JDK9以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器，用户会收到一个警告信息，提示CMS未来将会废弃

JDK14 删除了CMS垃圾回收器

​			移除了CMS垃圾回收期，如果在jdk14使用 CMS 的话 JVM不会报错，只会给出一个waring 信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM



# G1回收器：区域分代化

**既然我们已经有了前面几个强大的GC,为什么还要发布 Garbage First?**

​	原因就在于应用程序所应对的业务越来越大，复杂、用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC有跟不上实际的需求，所以才会不断的尝试对GC进行优化，G1,垃圾回收期时在jdk1.7之后引入的一个新的垃圾回收器，时当今收集器技术发展的最前沿成果之一

与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量，

官方给G1设定的目标时在延迟可控的情况下尽可能的高的吞吐量，所以才担当 全功能收集器 的众人和期望



G1**概述**

  它把对内存分割为很过个不相关的区域(Region)（物理上不连续的），使用不同的Region来表示Eden、幸存者0区、幸存者1区、老年代等

G1 Gc有计划的避免在整个Java 堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得空间大小以及回收所需要时间），在后台委会一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region

由于这种方式的则重点在于回收垃圾最大量的区间(Region)、所以我们给G1一个名字：垃圾优先

G1 是一款面向服务的应用的垃圾收集器，主要针对配备多个CPU及大容量内存的机器，以及高概率满足GC停顿时间同时，还兼顾高吞吐量的性能特征

在JDK1.7正式引入G1, jdk9称为默认垃圾回收期

**优势**

<font color=blue>并行与并发</font>

​			并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW

​			并发性：G1拥有与应用程序交替执行能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

<font color=blue>分代收集：</font>

​			从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区，但从堆的结构上看，它不要求整个Eden区，年轻代或者老年代都是连续的，也不坚持固定大小和固定数量

将堆空间分为若干个区域(Region)、这些区域中包含了逻辑上的年轻代和老年代

​	和之前的各类回收器不同，它同时兼顾年轻代和老年代，对比其他回收器，或者工作在年轻代、或者工作在老年代

<font color=blue>空间整合</font>

​	CMS 标记-清除 算法、内存碎片、若干次Full GC后进行一次碎片整理

​	G1将内存分为一个个的region、内存的回收是以region作为基础单位的Region之间是复制算法、但整个堆上实际可看作标记-压缩算法，两种算法都可以避免内存碎片，这种特性有利于程序长时间运行、分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC,尤其是当Java堆非常大的时候，G1的优势 更加明显

<font color=blue>可预测的停顿时间模型（软实时soft real-time）</font>

​	这是G1相对于CMS的另外一个大优势，G1除了追求低停顿，还能建立可预测的停顿时间模型，能让可使用者明确执行一个长度M毫秒的时间片段内，消耗在垃圾收集上的时间变得超过M毫秒

由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制

G1跟踪各个Region里面的垃圾堆积价值大小(回收所获得空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region，保证了G1收集器在有限的时间内可以获取尽可能搞得收集效率

相比于CMS GC,G1未必能做的CMS最后的情况下的低延迟、但是最差情况要好很多



缺点

相较于CMS, G1还不具备全方位、压倒性优略，比如用户程序运行过程中，G1无论时为了垃圾收集产生的内存占用(Footprint)还时程序运行时的额外执行负载(Overload)都要比CMS要高

从经验上来说，从小内存应用上CMS的表现大概率会由于G1,而G1在大内存应用上则发挥其优势，平衡点在6-8GC之间

**参数设置**

-XX:+UseG1GC 手动设置

-XX:+G1HeapRegionSize 设置每个Region的大小，值时2的幂，范围1mb-32mb。目标时根据最小的Java堆大小划分出月2048个区域，默认时堆内存的1/2000

-XX:MaxGCPauseMillis 设置期望达到GC停顿时间，默认200ms

-XX:ParallelGCThreads 设置STW时GC线程数的值，最大设置8

-XX:ConcGCThreads 设置并发阶段线程数，将n设置为并发垃圾回收线程数(ParallelGCThreads)的1/4左右

-XX:InitatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阙值 超过此值 就触发GC 默认45



**使用场景**

  面向服务的应用，针对具有大内存，多处理器的机器(普通大小的堆里面表现并不惊喜)

​	最主要的应用时需要低GC延迟，并具有大堆的应用程序提供解决方案

​		比如：在堆大小约6GB或更大，可预测的暂停时间可以低于0.5秒，G1通过每次只清理一部分而不是全部的Region的增量方式清理来保证每次GC停顿时间不会过长

  用来替换JDK5中的CMS收集器，下面情况使用G1可能比CMS好

​		超过50%的Java堆被活动数据占用

​		对象分配频率或年轻代提升频率变化大

​		GC停顿时间过长

 









